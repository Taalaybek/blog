<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Laravel Orchid</title>
    <link href="https://blog.orchid.software/blog" />
    <link type="application/atom+xml" rel="self" href="https://blog.orchid.software/feed.atom" />
    <updated>2020-10-12T00:26:21+00:00</updated>
    <id>https://blog.orchid.software/feed.atom</id>
    <author>
        <name>Alexandr Chernyaev</name>
    </author>
                <entry>
            <id>https://blog.orchid.software/lasting-stack</id>
            <link type="text/html" rel="alternate" href="https://blog.orchid.software/lasting-stack" />
            <title>What stack does Orchid use?</title>
            <published>2020-10-12T00:00:00+00:00</published>
            <updated>2020-10-12T00:00:00+00:00</updated>
            <author>
                <name>Alexandr Chernyaev</name>
            </author>
            <summary type="html">There are a lot of different stacks in trend right now for building an application. Every year or two, a new product appears that causes a lot of hype on the net and people to rush to rewrite their projects.

There are a lot of different stacks in trend......</summary>
            <content type="html"><![CDATA[
                <p>There are a lot of different stacks in trend right now for building an application. Every year or two, a new product appears that causes a lot of hype on the net and people to rush to rewrite their projects.</p>

<p>There are a lot of different stacks in trend right now for building an application. Every year or two, a new product appears that causes a lot of hype on the net and people to rush to rewrite their projects.</p>

<p>But the laravel Orchid administration panel is in no hurry to make changes.
Does not participate in page building:</p>

<ul>
<li>React</li>
<li>Vue</li>
<li>Tailwind css</li>
<li>Alpine.js</li>
<li>Livewire</li>
</ul>

<p>It may seem that this is some old product. Indeed, the first public version was published in 2016. One of the factors that we have been around for so long is the principle of "don't run after the crowd."</p>

<h4>There is such an interesting but controversial term as "The Hype Cycle".</h4>

<p><img src="/assets/img/lasting-stack/gartner_hype_cycle.svg" alt="noize" /></p>

<ul>
<li>First, all blogs and famous people in the community talk about new technology.</li>
<li>Users start to build new projects with it or try to build into existing ones.</li>
<li>Interest on the part of public figures is fading away. Developers are beginning to face problems that can only be solved by major releases that are dragging on.</li>
<li>People understand the strong and weak side. Technology begins to be applied in a narrower range of tasks</li>
<li>The technology occupies a niche market and is growing slowly.</li>
</ul>

<p>Does this sound familiar to you? I've seen people post in <code>React</code>, but after tweeting:</p>

<p><img src="/assets/img/lasting-stack/twit.png" alt="noize" /></p>

<p>Let's try <code>Vue</code> on real projects, then abandon it in favor
<code>Alpine.js</code> etc. This is not really a need. This is a trend!</p>

<h4>Build a product during a trend blizzard</h4>

<p>When I released the 0.x version, they used <code>jQuery</code>, and the most popular request was the conversion to <code>Vue</code>. Then I fell for this bait and began to rewrite the ready-made working code using the rapidly gaining popularity framework. After a few sleepless nights, the work was ready.
The public reaction was, "Oh cool! Another technology was rewritten to Vue," and that's it!
From this, there were no more users, since the offered functions have not changed. There are also no more change requests.</p>

<p><img src="/assets/img/lasting-stack/backend-vs-frontend.png" alt="backend-vs-frontend" /></p>

<p>In place of this, I received modern technology that took even more time to maintain it. Since first I had to do the work on <code>laravel</code>, and then continue<code>vue</code>.</p>

<p>This separation works great for a full-time job. One team worked on <code>PHP</code>, and the other on<code>JS</code> But this is an open and free product, where enthusiasts make changes in their free time. Now, for minor edits, more knowledge and skills were required from a person.</p>

<p>It was obvious that this was not very suitable for us at such a slow pace of work. Therefore, we drew attention to more classic <code>JS</code> frameworks, the purpose of which is not to convert <code>JSON</code> into <code>DOM</code> elements. To supplement an existing page, this choice was <code>Stimulus</code> from the <code>Ruby on rails</code> and<code>Basecamp</code> teams. At the same time, retaining the advantage of fast page loads. This allowed us to abandon the use of <code>API</code> and use the familiar <code>Blade</code>, introducing dynamic behavior only slightly.</p>

<p>In 2020, again, faced with questions, but let's change everything to <code>Livewire</code>, and now I demand clear justifications of what advantages we will get. Over the years of development, I tried many competitors, saw how they were written about on <code>laravel-news.com</code>, discussed <code>twitter</code>, etc.</p>

<p>But most of them did not last even a year. Following ever-changing trends, using inappropriate technologies, and fatigued developers were the main factors behind stopping development. Of course, there are exceptions in the form of the official <code>Nova</code> package, but at least two full-time developers working on it.</p>

<p>I'm sure there will be many more coming out soon.
Administration panels on TALL stack. But before using them,
think that they may not exist for a year. This solves the same problems as before. After all, what's the difference what is used as a CSS solution in the <code>Bootstrap</code> or <code>Bulma</code> admin area if you don't need to know them in order to use them.</p>
            ]]></content>
        </entry>
            <entry>
            <id>https://blog.orchid.software/what-are-a-screen-and-its-responsibility</id>
            <link type="text/html" rel="alternate" href="https://blog.orchid.software/what-are-a-screen-and-its-responsibility" />
            <title>What are a Screen and its responsibility?</title>
            <published>2020-10-11T00:00:00+00:00</published>
            <updated>2020-10-11T00:00:00+00:00</updated>
            <author>
                <name>Alexandr Chernyaev</name>
            </author>
            <summary type="html">The screen is a rather unusual term for web developers. It means a unique set of components that a user can see on a page.

For example, when building a simple blog, we will have only two unique pages. Home and page to display text. In fact, we have just......</summary>
            <content type="html"><![CDATA[
                <p>The screen is a rather unusual term for web developers. It means a unique set of components that a user can see on a page.</p>

<p>For example, when building a simple blog, we will have only two unique pages. Home and page to display text. In fact, we have just two screens. There can be as many pages in our blog as you want. But there are only two truly unique screens.</p>

<p>Let's continue the blog analogy. Each of our pages has a header, menu, footer. And all changes to the input of the transfer and views take place in the workspace. In the Laravel Orchid admin panel, the <code>Screen</code> class is intended to control this workspace.</p>

<p>Now that we've clarified a bit what the screen is, we can go deeper. A good question may arise here: The workspace of an application usually contains a lot of logic, somewhere you need to take values from the database, somewhere to display them in a table. Is it possible to unite this? Don't get the noodle code?</p>

<p>In fact, the responsibility is divided. Let's try to understand how popular single-page applications work. Some script accesses the service <code>API</code> for data and receives a <code>JSON</code> response where all the information is contained to display the content. Something like this:</p>

<pre><code class="language-json">[
  {
    "id": 1,
    "title": "sunt aut facere repellat provident occaecati...",
    "body": "quia et suscipit suscipit recusandae ..."
  },
  {
    "id": 2,
    "title": "qui est esse",
    "body": "est rerum tempore vitae sequi sin..."
  },
  {
    "id": 3,
    "title": "ea molestias quasi exercitationem repellat...",
    "body": "et iusto sed quo iure voluptatem occaecati omnis..."
  },
  ...
</code></pre>

<p>In fact, this <code>API</code> prepares all the necessary information that might be required to display a blog post. By the same endpoint principle, Orchid screens have a <code>query</code> method to prepare all the information.</p>

<pre><code class="language-php">/**
 * Query data
 *
 * @return array
 */
public function query(): array
{
  return [
    'posts' =&gt; [
      new Repository([
        "id"    =&gt; 1,
        "title" =&gt; "sunt aut facere repellat provident occaecati...",
        "body"  =&gt; "quia et suscipit suscipit recusandae ...",
      ]),
      new Repository([
        "id"    =&gt; 2,
        "title" =&gt; "qui est esse",
        "body"  =&gt; "est rerum tempore vitae sequi sin...",
      ]),
      new Repository([
        "id"    =&gt; 3,
        "title" =&gt; "ea molestias quasi exercitationem repellat...",
        "body"  =&gt; "et iusto sed quo iure voluptatem occaecati omnis...",
      ]),
    ]
  ];
}
</code></pre>

<p>After receiving <code>JSON</code> in single-page apps start to render this,
for example, using <code>front-end</code> frameworks, create some templates.</p>

<p>The same templates we have in Laravel Orchid screens expect you to pass them in the layouts method. For example, let's make a table (<code>php artisan orchid: table ExampleTable</code>):</p>

<pre><code class="language-php">use Orchid\Screen\TD;
use Orchid\Screen\Layouts\Table;

class BlogListLayout extends Table
{
  /**
   * Data source.
   *
   * @var string
   */
  protected $target = 'posts';

  /**
   * @return TD[]
   */
  protected function columns() : array
  {
    return [
        TD::set('id'),
        TD::set('title'),
        TD::set('body'),
    ];
  }
}
</code></pre>

<p>In <code>target</code>, we indicated which prepared value (from <code>query</code>) needs to be passed to our template and declared the columns in our table.</p>

<p>Now all that remains is to indicate the created template in the screen class:</p>

<pre><code class="language-php">/**
 * Views
 *
 * @return array
 */
public function layout() : array
{
    return [
        BlogListLayout::class
    ];
}
</code></pre>

<p>In fact, the screen united but did not take on unnecessary responsibility.
If you follow which, you will not have code noodles. At the same time, just by looking at the screen code, you will already know what data and where it receives from and what templates will be displayed.</p>
            ]]></content>
        </entry>
            <entry>
            <id>https://blog.orchid.software/svg-icons</id>
            <link type="text/html" rel="alternate" href="https://blog.orchid.software/svg-icons" />
            <title>SVG Icons</title>
            <published>2020-09-19T00:00:00+00:00</published>
            <updated>2020-09-19T00:00:00+00:00</updated>
            <author>
                <name>Alexandr Chernyaev</name>
            </author>
            <summary type="html">In the latest release of the package, I replaced &lt;code&gt;Icon Fonts&lt;/code&gt; in favor of the SVG format, which means that now icons are available in a vector.

Previously, if you needed to display your own (or from the Internet) icon, you could translate it......</summary>
            <content type="html"><![CDATA[
                <p>In the latest release of the package, I replaced <code>Icon Fonts</code> in favor of the SVG format, which means that now icons are available in a vector.</p>

<p>Previously, if you needed to display your own (or from the Internet) icon, you could translate it into a font and include a CSS file with a description. Now, this is not needed. It is enough to copy the desired icon to the project.</p>

<p>Let's do it together. Let's say we want to include an icon from the popular Font Awesome. To do this, select a suitable storage directory, for example, create a new <code>icons</code> directory and a <code>fontawesome</code> subdirectory:</p>

<pre><code class="language-bash">resources
  - css 
  - icons
      -- fontawesome 
  - js
  - lang
  - views
</code></pre>

<p>Load the appropriate icons into the new directory, for example, this <a href="https://github.com/FortAwesome/Font-Awesome/blob/ce084cb3463f15fd6b001eb70622d00a0e43c56c/svgs/solid/address-book.svg">notebook icon</a>. Then we will indicate to the package the directory in which we need to search for our images, for this we will edit the configuration file <code>config/platform.php</code>:</p>

<pre><code class="language-php">'icons' =&gt; [
    'fa' =&gt; resource_path('icons/fontawesome')
],
</code></pre>

<p>All we have done here is declare the prefix by which we will refer to fa and the directory where the files are located.
To display in the components of the package, you only need to pass the prefix + name, for example, the definition of the icon in the menu will look like this:</p>

<pre><code class="language-php">ItemMenu::label('Example of custom icons')
    -&gt;icon('fa.address-book')
    -&gt;url(#);
</code></pre>

<p>Moreover, if, for some reason, your project does not have <a href="http://orchid.software/">Laravel Orchid</a>, then a separate <a href="https://github.com/orchidsoftware/blade-icons">package has been prepared for the Blade and SVG template engine</a>.</p>
            ]]></content>
        </entry>
            <entry>
            <id>https://blog.orchid.software/draw-model-charts</id>
            <link type="text/html" rel="alternate" href="https://blog.orchid.software/draw-model-charts" />
            <title>Draw model charts</title>
            <published>2020-08-05T00:00:00+00:00</published>
            <updated>2020-08-05T00:00:00+00:00</updated>
            <author>
                <name>Alexandr Chernyaev</name>
            </author>
            <summary type="html">Building charts can be awkward, but since &lt;code&gt;7.15.0&lt;/code&gt;, a trait has been added to Laravel Orchid to generate group and time data.
To use it, you should add the trait &lt;code&gt;Orchid\Metrics\Chartable&lt;/code&gt; to the model.

Let&#039;s try it in action and......</summary>
            <content type="html"><![CDATA[
                <p>Building charts can be awkward, but since <code>7.15.0</code>, a trait has been added to <a href="http://orchid.software/">Laravel Orchid</a> to generate group and time data.
To use it, you should add the trait <code>Orchid\Metrics\Chartable</code> to the model.</p>

<p>Let's try it in action and form a visual dynamics of user registrations. To do this, let's create a new layer using the command:</p>

<pre><code class="language-php"> php artisan orchid:chart DynamicsOfRegistrations
</code></pre>

<p>In <code>app/Orchid/Layouts</code> directory, a new class will be created, we will add the name and the target key to it:</p>

<pre><code class="language-php">namespace App\Orchid\Layouts;

use Orchid\Screen\Layouts\Chart;

class DynamicsOfRegistrations extends Chart
{
    /**
     * Add a title to the Chart.
     *
     * @var string
     */
    protected $title = 'New members';

    /**
     * Data source.
     *
     * The name of the key to fetch it from the query.
     * The results of which will be elements of the. Wet.
     *
     * @var string
     */
    protected $target = 'registrations';
}
</code></pre>

<p>The standard package comes with a screen displaying all users. Why not use it. Let's add a new query value to the <code>UserListScreen</code>:</p>

<pre><code class="language-php">public function query(): array
{
    return [
        'registrations' =&gt; [
            User::countByDays()-&gt;toChart('Users'),
        ],
        // ... other values
    ]
}
</code></pre>

<p>All that's left is to put a layer on the screen:</p>

<pre><code class="language-php">public function layout(): array
{
    return [
        DynamicsOfRegistrations::class,
        // ... other layouts
    ];
}
</code></pre>

<p>Now going to the user list page, we will see how many users have registered in the last month:</p>

<p><img src="/assets/img/draw-model-charts/x4w1qcdys4p2qtu9ect8.png" alt="Dynamics Of Registrations" /></p>

<p>That's great. But let's also show the statistics of how many users have enabled two-factor authentication (by the way, here is an <a href="https://dev.to/tabuna/how-to-enable-two-factor-authentication-in-laravel-orchid-2eim">article on how to enable it</a>). For this, we will also create a new layer, but with different values:</p>

<pre><code class="language-php">namespace App\Orchid\Layouts;

use Orchid\Screen\Layouts\Chart;

class UsageTwoFactorAuth extends Chart
{
    /**
     * Add a title to the Chart.
     *
     * @var string
     */
    protected $title = 'Usage two-factor authentication';

    /**
     * Available options:
     * 'bar', 'line',
     * 'pie', 'percentage'.
     *
     * @var string
     */
    protected $type = 'pie';

    /**
     * Data source.
     *
     * The name of the key to fetch it from the query.
     * The results of which will be elements of the chart.
     *
     * @var string
     */
    protected $target = 'usageTwoFactorAuth';
}
</code></pre>

<p>The output of the request will be slightly different:</p>

<pre><code class="language-php">public function query(): array
{
    $usageTwoFactorAuth = User::countForGroup('uses_two_factor_auth')
        -&gt;toChart(function (bool $state) {
            return $state ? 'Enabled' : 'Disabled';
        });


    return [
        'usageTwoFactorAuth' =&gt; $usageTwoFactorAuth,
        // ...
    ]
}
</code></pre>

<p>Let's not forget to bring out the layer created:</p>

<pre><code class="language-php">public function layout(): array
{
    return [
        DynamicsOfRegistrations::class,
        UsageTwoFactorAuth::class
        // ... other layouts
    ];
}
</code></pre>

<p>Now, going to the user list page, we will also see the ratio of users who have enabled two-factor authentication:</p>

<p><img src="/assets/img/draw-model-charts/t3alibhlbh3ggswv616r.png" alt="UsageTwoFactorAuth" /></p>

<p>That's it! Our minimum example is ready. You can learn more about building charts on the <a href="https://orchid.software/en/docs/layouts/charts">documentation page</a>.</p>
            ]]></content>
        </entry>
            <entry>
            <id>https://blog.orchid.software/reusing-layers</id>
            <link type="text/html" rel="alternate" href="https://blog.orchid.software/reusing-layers" />
            <title>Reusing layers</title>
            <published>2020-07-01T00:00:00+00:00</published>
            <updated>2020-07-01T00:00:00+00:00</updated>
            <author>
                <name>Alexandr Chernyaev</name>
            </author>
            <summary type="html">Layouts are easy to reuse when fields are related to the relations of different models. During installation, we have a layer for defining permissions, which is used immediately at the user and roles editing screen. But sometimes you want to apply the......</summary>
            <content type="html"><![CDATA[
                <p>Layouts are easy to reuse when fields are related to the relations of different models. During installation, we have a layer for defining permissions, which is used immediately at the user and roles editing screen. But sometimes you want to apply the same set of fields with different values. Let's consider an example when you need to specify an address.</p>

<p>Such a set will be both for the client, the customer, and it will appear twice on the same form (for example, in order, delivery and invoice). To solve this situation, you do not need to create and describe almost identical layouts. Instead, let's add logic to one single layer.</p>

<pre><code class="language-php">namespace App\Orchid\Layouts;

use Orchid\Screen\Field;
use Orchid\Screen\Fields\Input;
use Orchid\Screen\Fields\Label;
use Orchid\Screen\Layouts\Rows;

class AddressLayout extends Rows
{
    /**
     * Used to create the title of a group of form elements.
     *
     * @var string|null
     */
    protected $title;

    /**
     * Prefix for a field name
     *
     * @var string
     */
    protected $prefix;

    /**
     * ReusableEditLayout constructor.
     *
     * @param string      $prefix
     * @param string|null $title
     */
    public function __construct(string $prefix, string $title = null)
    {
        $this-&gt;prefix = $prefix;
        $this-&gt;title = $title;
    }

    /**
     * Views.
     *
     * @return Field[]
     */
    protected function fields(): array
    {
        return [
            Input::make($this-&gt;prefix . '.address')
                -&gt;required()
                -&gt;title('Address')
                -&gt;placeholder('177A Bleecker Street'),
        ];
    }
}
</code></pre>

<p>Now, when used, we will pass the prefix and header values:</p>

<pre><code class="language-php">public function layout(): array
{
    return [
        Layout::columns([
            new AddressLayout('order.shipping_address', 'Shipping Address'),
            new AddressLayout('order.invoice_address', 'Invoice Address'),
        ]),
    ];
}
</code></pre>

<p>But this is also inconvenient. Why? Now in the definition, we will think, do we need to end the prefix with a dot? And also, specify strange names through the concatenation <code>$this-&gt;prefix. '.address'</code>.</p>

<p>Let's fix it! Since the main thing is to return an array of objects, you can modify the fields before returning, as well as take care of the point in the constructor:</p>

<pre><code class="language-php">namespace App\Orchid\Layouts;

use Illuminate\Support\Str;
use Orchid\Screen\Field;
use Orchid\Screen\Fields\Input;
use Orchid\Screen\Layouts\Rows;

class AddressLayout extends Rows
{
    /**
     * Used to create the title of a group of form elements.
     *
     * @var string|null
     */
    protected $title;

    /**
     * Prefix for a field name
     *
     * @var string
     */
    protected $prefix;

    /**
     * ReusableEditLayout constructor.
     *
     * @param string      $prefix
     * @param string|null $title
     */
    public function __construct(string $prefix, string $title = null)
    {
        $this-&gt;prefix = Str::finish($prefix, '.');
        $this-&gt;title = $title;
    }

    /**
     * Get the fields elements to be displayed.
     *
     * @return Field[]
     */
    protected function fields(): array
    {
        return $this-&gt;addPrefix([
            Input::make('address')
                -&gt;required()
                -&gt;title('Address')
                -&gt;placeholder('177A Bleecker Street'),
        ]);
    }

    /**
     * @param Field[] $fields
     *
     * @return array
     */
    protected function addPrefix(array $fields): array
    {
        return array_map(function (Field $field) {
            return $field-&gt;set('name',
                $this-&gt;prefix . $field-&gt;get('name')
            );
        }, $fields);
    }
}
</code></pre>

<p>The main task has been solved. Now, the reuse of a class with one set of fields for the address does not make you think and duplicate it.</p>
            ]]></content>
        </entry>
            <entry>
            <id>https://blog.orchid.software/dive-into-elements-and-forms</id>
            <link type="text/html" rel="alternate" href="https://blog.orchid.software/dive-into-elements-and-forms" />
            <title>Dive into “Elements and Forms”</title>
            <published>2019-09-15T00:00:00+00:00</published>
            <updated>2019-09-15T00:00:00+00:00</updated>
            <author>
                <name>Alexandr Chernyaev</name>
            </author>
            <summary type="html">The use of automated “Laravel admin areas” can be summarized as “Forms over data” as the main tool is to provide a user interface for viewing, adding, and modifying data.

In this case, the form can consist of many different fields for entering......</summary>
            <content type="html"><![CDATA[
                <p>The use of automated “Laravel admin areas” can be summarized as “Forms over data” as the main tool is to provide a user interface for viewing, adding, and modifying data.</p>

<p>In this case, the form can consist of many different fields for entering data, so how does such an important element work?</p>

<h2>Field view</h2>

<p>Any field in the Orchid Platform is just a setting above the view that passes data to the template. Let's create a new class to see what it consists of:</p>

<pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace App\Orchid\Fields;

use Orchid\Screen\Field;

/**
 * Class MyField
 */
class MyField extends Field
{
    /**
     * Blade template
     * 
     * @var string
     */
    protected $view = '';

    /**
     * Default attributes value.
     *
     * @var array
     */
    protected $attributes = [];

    /**
     * Attributes available for a particular tag.
     *
     * @var array
     */
    protected $inlineAttributes = [];

    /**
     * @param string|null $name
     *
     * @return self
     */
    public static function make(string $name = null): self
    {
        return (new static())-&gt;name($name);
    }
}
</code></pre>

<p>The <code>view</code> property defines the Blade template to which the data will be passed, the default values are listed in <code>attributes</code>, and <code>inlineAttributes</code> defines the keys needed to be specified in HTML format, for example:</p>

<pre><code class="language-html">First name: &lt;input type="text" name="name"&gt;&lt;br&gt;
</code></pre>

<p>In this example, the inline attribute is a type and the name specified directly in the tag. And the <code>make()</code> method is only for quick and convenient initialization since any form that needs to add or change data must have it.
Let's update just the created class and add a template:</p>

<pre><code class="language-php">// app/Orchid/Fields/MyField.php
declare(strict_types=1);

namespace App\Orchid\Fields;

use Orchid\Screen\Field;

/**
 * Class MyField
 */
class MyField extends Field
{
    /**
     * Blade template
     *
     * @var string
     */
    protected $view = 'myField';

    /**
     * Default attributes value.
     *
     * @var array
     */
    protected $attributes = [
        'title' =&gt; 'First name'
    ];

    /**
     * Attributes available for a particular tag.
     *
     * @var array
     */
    protected $inlineAttributes = [
        'name',
        'type'
    ];

    /**
     * @param string|null $name
     *
     * @return self
     */
    public static function make(string $name = null): self
    {
        return (new static())-&gt;name($name);
    }
}
// resources/views/myField.blade.php
{{$title}}: &lt;input @include('platform::partials.fields.attributes', ['attributes' =&gt; $attributes])&gt;&lt;br&gt;
</code></pre>

<p>To try a new field, you need to use the built-in <code>render()</code> method:</p>

<pre><code class="language-php">Route::get('/', function () {
    $input = MyField::make('name');

    return $input-&gt;render();
});
</code></pre>

<p>The browser will return the template just specified. Let's try to add some elements:</p>

<pre><code class="language-php">Route::get('/', function () {
    $input = MyField::make('name')
        -&gt;title('How your name?')
        -&gt;placeholder('Sheldon Cooper')
        -&gt;value('Alexandr Chernyaev');

    return $input-&gt;render();
});
</code></pre>

<p>After we refresh the page, it displays a new title instead of the default one, but neither the placeholder nor the value has been applied. This is because they were not specified in <code>inlineAttributes</code>. Let's fix that:</p>

<pre><code class="language-php">/**
 * Attributes available for a particular tag.
 *
 * @var array
 */
protected $inlineAttributes = [
    'name',
    'type',
    'placeholder',
    'value'
];
</code></pre>

<p>After that, each attribute will be drawn in our template.</p>

<h2>But how does the form process the data?</h2>

<p>In normal use, there is no need to render every element and fill it with data. There is a special builder for this - <code>Orchid\Screen\Builder</code></p>

<pre><code class="language-php">Route::get('/', function () {

    $fields[] = MyField::make('name');

    $repository = new Repository([
        'name' =&gt; 'Alexandr Chernyaev',
    ]);

    $builder = new Builder($fields, $repository);

    return $builder-&gt;generateForm();
});
</code></pre>

<p>Essentially, the builder maps the names from the store to the required form as a value. At the same time, it has the ability to enter into the depth of the object using dot-notation.</p>

<pre><code class="language-php">Route::get('/', function () {

    $fields[] = MyField::make('name.ru');

    $repository = new Repository([
        'name' =&gt; [
            'en' =&gt; 'Alexandr Chernyaev',
            'ru' =&gt; 'Александр Черняев'
        ],
    ]);

    $builder = new Builder($fields, $repository);

    return $builder-&gt;generateForm();
});
</code></pre>

<p>You can also specify the required language and prefix, for example:</p>

<pre><code class="language-php">Route::get('/', function () {

    $fields[] = MyField::make('name');

    $repository = new Repository([
        'en' =&gt; [
            'name' =&gt; 'Alexandr Chernyaev',
        ],
        'ru' =&gt; [
            'name' =&gt; 'Александр Черняев',
        ]
    ]);

    $builder = new Builder($fields, $repository);
    $builder-&gt;setLanguage('en');

    return $builder-&gt;generateForm();
});
</code></pre>

<h2>And it's all?</h2>

<p>That's right. This is exactly the approach used in the Orchid admin panel for Laravel when rendering screens and allowing you to automate the construction of forms with data.</p>
            ]]></content>
        </entry>
            <entry>
            <id>https://blog.orchid.software/comparison-of-administration-panels</id>
            <link type="text/html" rel="alternate" href="https://blog.orchid.software/comparison-of-administration-panels" />
            <title>Comparison of administration panels</title>
            <published>2019-03-03T00:00:00+00:00</published>
            <updated>2019-03-03T00:00:00+00:00</updated>
            <author>
                <name>Alexandr Chernyaev</name>
            </author>
            <summary type="html">In 2017, Taylor Otwell published several articles, not comparing features or convenience, but the code results for various frameworks, where Laravel was the clear favorite.

Average class size comparison


  Framework Average Class Size Comparison ... I......</summary>
            <content type="html"><![CDATA[
                <p>In 2017, <a href="http://medium.com/@taylorotwell">Taylor Otwell</a> published several articles, not comparing features or convenience, but the code results for various frameworks, where Laravel was the clear favorite.</p>

<p><a href="http://medium.com/@taylorotwell/framework-average-class-size-comparison-63722a8ed9cf">Average class size comparison</a></p>

<blockquote>
  <p>Framework Average Class Size Comparison ... I published some average method complexity statistics yesterday. One rebuttal to those statistics was that Laravel's ...</p>
</blockquote>

<p><a href="http://medium.com/@taylorotwell/measuring-code-complexity-64356da605f9">and code complexity comparison</a></p>

<blockquote>
  <p>Framework Code Complexity Comparison ... Last week, as I was refactoring and cleaning Laravel for the 5.4 release, Graham Campbell showed me some code complexity ...</p>
</blockquote>

<p>The measurements were taken using the <a href="https://github.com/sebastianbergmann/phploc">phploc</a> tool. I think it would be a good idea to do the same analysis for the administration packages. <strong>Less is better.</strong></p>

<p><strong>Backpack:</strong></p>

<ul>
<li>17 834 lines</li>
<li>23 medium long,</li>
<li>9.51 average class difficulty</li>
</ul>

<p><strong>Nova:</strong></p>

<ul>
<li>19 701 lines</li>
<li>10 medium length</li>
<li>3.26 average class difficulty</li>
</ul>

<p><strong>SleepingOwl:</strong></p>

<ul>
<li>27 256 lines</li>
<li>16 medium long</li>
<li>4.81 average class difficulty</li>
</ul>

<p><strong>Orchid:</strong></p>

<ul>
<li>12,753 lines</li>
<li>10 medium length</li>
<li>2.68 average class difficulty</li>
</ul>

<p><strong>Voyager:</strong></p>

<ul>
<li>10,744 lines</li>
<li>11 medium long</li>
<li>4.59 average class difficulty</li>
</ul>

<p><strong>Z-song/laravel-admin:</strong></p>

<ul>
<li>26,292 lines</li>
<li>22 medium length</li>
<li>6.40 average class difficulty</li>
</ul>

<p>Measurements were carried out in the <code>src</code> directory, only for files with the <code>.php</code> extension, the latest versions of packages as of March 3, 2019, were used.</p>
            ]]></content>
        </entry>
    </feed>
